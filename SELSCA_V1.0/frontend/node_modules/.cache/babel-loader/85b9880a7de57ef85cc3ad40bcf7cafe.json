{"ast":null,"code":"import { schemeCategory10 as e, schemeAccent as r, schemeDark2 as n, schemePaired as t, schemePastel1 as o, schemePastel2 as i, schemeSet1 as u, schemeSet2 as a, schemeSet3 as l, schemeBrBG as s, schemePRGn as c, schemePiYG as f, schemePuOr as p, schemeRdBu as d, schemeRdGy as m, schemeRdYlBu as h, schemeRdYlGn as g, schemeSpectral as y, interpolateBrBG as b, interpolatePRGn as v, interpolatePiYG as _, interpolatePuOr as w, interpolateRdBu as O, interpolateRdGy as k, interpolateRdYlBu as z, interpolateRdYlGn as A, interpolateSpectral as j, schemeBlues as E, schemeGreens as x, schemeGreys as I, schemeOranges as q, schemePurples as S, schemeReds as R, schemeBuGn as C, schemeBuPu as G, schemeGnBu as V, schemeOrRd as T, schemePuBuGn as P, schemePuBu as U, schemePuRd as D, schemeRdPu as M, schemeYlGnBu as $, schemeYlGn as B, schemeYlOrBr as F, schemeYlOrRd as H, interpolateBlues as J, interpolateGreens as K, interpolateGreys as L, interpolateOranges as N, interpolatePurples as Q, interpolateReds as W, interpolateTurbo as X, interpolateViridis as Y, interpolateInferno as Z, interpolateMagma as ee, interpolatePlasma as re, interpolateCividis as ne, interpolateWarm as te, interpolateCool as oe, interpolateCubehelixDefault as ie, interpolateBuGn as ue, interpolateBuPu as ae, interpolateGnBu as le, interpolateOrRd as se, interpolatePuBuGn as ce, interpolatePuBu as fe, interpolatePuRd as pe, interpolateRdPu as de, interpolateYlGnBu as me, interpolateYlGn as he, interpolateYlOrBr as ge, interpolateYlOrRd as ye, interpolateRainbow as be, interpolateSinebow as ve } from \"d3-scale-chromatic\";\nimport _e from \"lodash/isPlainObject\";\nimport we from \"lodash/get\";\nimport { useMemo as Oe } from \"react\";\nimport { rgb as ke } from \"d3-color\";\nimport ze from \"prop-types\";\nimport { scaleSequential as Ae, scaleDiverging as je, scaleQuantize as Ee, scaleLinear as xe, scaleOrdinal as Ie } from \"d3-scale\";\nfunction qe() {\n  return qe = Object.assign || function (e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var n = arguments[r];\n      for (var t in n) Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);\n    }\n    return e;\n  }, qe.apply(this, arguments);\n}\nfunction Se(e, r) {\n  (null == r || r > e.length) && (r = e.length);\n  for (var n = 0, t = new Array(r); n < r; n++) t[n] = e[n];\n  return t;\n}\nfunction Re(e, r) {\n  var n = \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (n) return (n = n.call(e)).next.bind(n);\n  if (Array.isArray(e) || (n = function (e, r) {\n    if (e) {\n      if (\"string\" == typeof e) return Se(e, r);\n      var n = Object.prototype.toString.call(e).slice(8, -1);\n      return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(e) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Se(e, r) : void 0;\n    }\n  }(e)) || r && e && \"number\" == typeof e.length) {\n    n && (e = n);\n    var t = 0;\n    return function () {\n      return t >= e.length ? {\n        done: !0\n      } : {\n        done: !1,\n        value: e[t++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar Ce = {\n    nivo: [\"#e8c1a0\", \"#f47560\", \"#f1e15b\", \"#e8a838\", \"#61cdbb\", \"#97e3d5\"],\n    category10: e,\n    accent: r,\n    dark2: n,\n    paired: t,\n    pastel1: o,\n    pastel2: i,\n    set1: u,\n    set2: a,\n    set3: l\n  },\n  Ge = Object.keys(Ce),\n  Ve = {\n    brown_blueGreen: s,\n    purpleRed_green: c,\n    pink_yellowGreen: f,\n    purple_orange: p,\n    red_blue: d,\n    red_grey: m,\n    red_yellow_blue: h,\n    red_yellow_green: g,\n    spectral: y\n  },\n  Te = Object.keys(Ve),\n  Pe = {\n    brown_blueGreen: b,\n    purpleRed_green: v,\n    pink_yellowGreen: _,\n    purple_orange: w,\n    red_blue: O,\n    red_grey: k,\n    red_yellow_blue: z,\n    red_yellow_green: A,\n    spectral: j\n  },\n  Ue = {\n    blues: E,\n    greens: x,\n    greys: I,\n    oranges: q,\n    purples: S,\n    reds: R,\n    blue_green: C,\n    blue_purple: G,\n    green_blue: V,\n    orange_red: T,\n    purple_blue_green: P,\n    purple_blue: U,\n    purple_red: D,\n    red_purple: M,\n    yellow_green_blue: $,\n    yellow_green: B,\n    yellow_orange_brown: F,\n    yellow_orange_red: H\n  },\n  De = Object.keys(Ue),\n  Me = {\n    blues: J,\n    greens: K,\n    greys: L,\n    oranges: N,\n    purples: Q,\n    reds: W,\n    turbo: X,\n    viridis: Y,\n    inferno: Z,\n    magma: ee,\n    plasma: re,\n    cividis: ne,\n    warm: te,\n    cool: oe,\n    cubehelixDefault: ie,\n    blue_green: ue,\n    blue_purple: ae,\n    green_blue: le,\n    orange_red: se,\n    purple_blue_green: ce,\n    purple_blue: fe,\n    purple_red: pe,\n    red_purple: de,\n    yellow_green_blue: me,\n    yellow_green: he,\n    yellow_orange_brown: ge,\n    yellow_orange_red: ye\n  },\n  $e = qe({}, Ce, Ve, Ue),\n  Be = Object.keys($e),\n  Fe = function Fe(e) {\n    return Ge.includes(e);\n  },\n  He = function He(e) {\n    return Te.includes(e);\n  },\n  Je = function Je(e) {\n    return De.includes(e);\n  },\n  Ke = {\n    rainbow: be,\n    sinebow: ve\n  },\n  Le = qe({}, Pe, Me, Ke),\n  Ne = Object.keys(Le),\n  Qe = function Qe(e, r) {\n    if (\"function\" == typeof e) return e;\n    if (_e(e)) {\n      if (function (e) {\n        return void 0 !== e.theme;\n      }(e)) {\n        if (void 0 === r) throw new Error(\"Unable to use color from theme as no theme was provided\");\n        var n = we(r, e.theme);\n        if (void 0 === n) throw new Error(\"Color from theme is undefined at path: '\" + e.theme + \"'\");\n        return function () {\n          return n;\n        };\n      }\n      if (function (e) {\n        return void 0 !== e.from;\n      }(e)) {\n        var t = function t(r) {\n          return we(r, e.from);\n        };\n        if (Array.isArray(e.modifiers)) {\n          for (var o, i = [], u = function u() {\n              var e = o.value,\n                r = e[0],\n                n = e[1];\n              if (\"brighter\" === r) i.push(function (e) {\n                return e.brighter(n);\n              });else if (\"darker\" === r) i.push(function (e) {\n                return e.darker(n);\n              });else {\n                if (\"opacity\" !== r) throw new Error(\"Invalid color modifier: '\" + r + \"', must be one of: 'brighter', 'darker', 'opacity'\");\n                i.push(function (e) {\n                  return e.opacity = n, e;\n                });\n              }\n            }, a = Re(e.modifiers); !(o = a()).done;) u();\n          return 0 === i.length ? t : function (e) {\n            return i.reduce(function (e, r) {\n              return r(e);\n            }, ke(t(e))).toString();\n          };\n        }\n        return t;\n      }\n      throw new Error(\"Invalid color spec, you should either specify 'theme' or 'from' when using a config object\");\n    }\n    return function () {\n      return e;\n    };\n  },\n  We = function We(e, r) {\n    return Oe(function () {\n      return Qe(e, r);\n    }, [e, r]);\n  },\n  Xe = ze.oneOfType([ze.func, ze.arrayOf(ze.string), ze.shape({\n    scheme: ze.oneOf(Be).isRequired,\n    size: ze.number\n  }), ze.shape({\n    datum: ze.string.isRequired\n  }), ze.string]),\n  Ye = ze.oneOfType([ze.string, ze.func, ze.shape({\n    theme: ze.string.isRequired\n  }), ze.shape({\n    from: ze.string.isRequired,\n    modifiers: ze.arrayOf(ze.array)\n  })]),\n  Ze = {\n    scheme: \"turbo\"\n  },\n  er = function er(e, r) {\n    var n = e.minValue,\n      t = e.maxValue,\n      o = void 0 !== n ? n : r.min,\n      i = void 0 !== t ? t : r.max,\n      u = Ae().domain([o, i]).clamp(!0);\n    if (\"colors\" in e) u.range(e.colors);else if (\"interpolator\" in e) u.interpolator(e.interpolator);else {\n      var a,\n        l = null != (a = e.scheme) ? a : Ze.scheme;\n      u.interpolator(Le[l]);\n    }\n    return u;\n  },\n  rr = function rr(e, r) {\n    return Oe(function () {\n      return er(e, r);\n    }, [e, r]);\n  },\n  nr = {\n    scheme: \"red_yellow_blue\",\n    divergeAt: .5\n  },\n  tr = function tr(e, r) {\n    var n,\n      t = e.minValue,\n      o = e.maxValue,\n      i = void 0 !== t ? t : r.min,\n      u = void 0 !== o ? o : r.max,\n      a = [i, i + (u - i) / 2, u],\n      l = .5 - (null != (n = e.divergeAt) ? n : nr.divergeAt),\n      s = je().domain(a).clamp(!0),\n      c = function c(e) {\n        return String(e);\n      };\n    if (\"colors\" in e) c = je().domain(a.map(function (e) {\n      return e - l * (u - i);\n    })).range(e.colors).interpolator();else if (\"interpolator\" in e) c = e.interpolator;else {\n      var f,\n        p = null != (f = e.scheme) ? f : nr.scheme;\n      c = Le[p];\n    }\n    return s.interpolator(function (e) {\n      return c(e + l);\n    });\n  },\n  or = function or(e, r) {\n    return Oe(function () {\n      return tr(e, r);\n    }, [e, r]);\n  },\n  ir = {\n    scheme: \"turbo\",\n    steps: 7\n  },\n  ur = function ur(e, r) {\n    var n = Ee().domain(e.domain || [r.min, r.max]).nice();\n    if (\"colors\" in e) n.range(e.colors);else {\n      var t = e.scheme || ir.scheme,\n        o = void 0 === e.steps ? ir.steps : e.steps,\n        i = Le[t],\n        u = Array.from({\n          length: o\n        }).map(function (e, r) {\n          return i(r * (1 / (o - 1)));\n        });\n      n.range(u);\n    }\n    return n;\n  },\n  ar = function ar(e, r) {\n    return Oe(function () {\n      return ur(e, r);\n    }, [e, r]);\n  },\n  lr = function lr(e, r) {\n    if (function (e) {\n      return \"sequential\" === e.type;\n    }(e)) return er(e, r);\n    if (function (e) {\n      return \"diverging\" === e.type;\n    }(e)) return tr(e, r);\n    if (function (e) {\n      return \"quantize\" === e.type;\n    }(e)) return ur(e, r);\n    throw new Error(\"Invalid continuous color scale config\");\n  },\n  sr = function sr(e, r) {\n    return Oe(function () {\n      return lr(e, r);\n    }, [e, r]);\n  },\n  cr = function cr(e, r) {\n    void 0 === r && (r = 16);\n    var n = e.domain();\n    if (\"thresholds\" in e) {\n      var t = [],\n        o = xe().domain(n).range([0, 1]);\n      return e.range().forEach(function (r, n) {\n        var i = e.invertExtent(r),\n          u = i[0],\n          a = i[1];\n        t.push({\n          key: n + \".0\",\n          offset: o(u),\n          stopColor: r\n        }), t.push({\n          key: n + \".1\",\n          offset: o(a),\n          stopColor: r\n        });\n      }), t;\n    }\n    var i = e.copy();\n    return 2 === n.length ? i.domain([0, 1]) : 3 === n.length && i.domain([0, .5, 1]), i.ticks(r).map(function (e) {\n      return {\n        key: \"\" + e,\n        offset: e,\n        stopColor: \"\" + i(e)\n      };\n    });\n  },\n  fr = function fr(e, r) {\n    if (\"function\" == typeof e) return e;\n    var n = \"function\" == typeof r ? r : function (e) {\n      return we(e, r);\n    };\n    if (Array.isArray(e)) {\n      var t = Ie(e),\n        o = function o(e) {\n          return t(n(e));\n        };\n      return o.scale = t, o;\n    }\n    if (_e(e)) {\n      if (function (e) {\n        return void 0 !== e.datum;\n      }(e)) return function (r) {\n        return we(r, e.datum);\n      };\n      if (function (e) {\n        return void 0 !== e.scheme;\n      }(e)) {\n        if (Fe(e.scheme)) {\n          var i = Ie($e[e.scheme]),\n            u = function u(e) {\n              return i(n(e));\n            };\n          return u.scale = i, u;\n        }\n        if (He(e.scheme)) {\n          if (void 0 !== e.size && (e.size < 3 || e.size > 11)) throw new Error(\"Invalid size '\" + e.size + \"' for diverging color scheme '\" + e.scheme + \"', must be between 3~11\");\n          var a = Ie($e[e.scheme][e.size || 11]),\n            l = function l(e) {\n              return a(n(e));\n            };\n          return l.scale = a, l;\n        }\n        if (Je(e.scheme)) {\n          if (void 0 !== e.size && (e.size < 3 || e.size > 9)) throw new Error(\"Invalid size '\" + e.size + \"' for sequential color scheme '\" + e.scheme + \"', must be between 3~9\");\n          var s = Ie($e[e.scheme][e.size || 9]),\n            c = function c(e) {\n              return s(n(e));\n            };\n          return c.scale = s, c;\n        }\n      }\n      throw new Error(\"Invalid colors, when using an object, you should either pass a 'datum' or a 'scheme' property\");\n    }\n    return function () {\n      return e;\n    };\n  },\n  pr = function pr(e, r) {\n    return Oe(function () {\n      return fr(e, r);\n    }, [e, r]);\n  };\nexport { Ge as categoricalColorSchemeIds, Ce as categoricalColorSchemes, Ne as colorInterpolatorIds, Le as colorInterpolators, Be as colorSchemeIds, $e as colorSchemes, cr as computeContinuousColorScaleColorStops, Ke as cyclicalColorInterpolators, Pe as divergingColorInterpolators, nr as divergingColorScaleDefaults, Te as divergingColorSchemeIds, Ve as divergingColorSchemes, lr as getContinuousColorScale, tr as getDivergingColorScale, Qe as getInheritedColorGenerator, fr as getOrdinalColorScale, ur as getQuantizeColorScale, er as getSequentialColorScale, Ye as inheritedColorPropType, Fe as isCategoricalColorScheme, He as isDivergingColorScheme, Je as isSequentialColorScheme, Xe as ordinalColorsPropType, ir as quantizeColorScaleDefaults, Me as sequentialColorInterpolators, Ze as sequentialColorScaleDefaults, De as sequentialColorSchemeIds, Ue as sequentialColorSchemes, sr as useContinuousColorScale, or as useDivergingColorScale, We as useInheritedColor, pr as useOrdinalColorScale, ar as useQuantizeColorScale, rr as useSequentialColorScale };","map":null,"metadata":{},"sourceType":"module"}